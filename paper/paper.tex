\documentclass{sigplanconf}
\usepackage[1stsubmission]{oopsla2016}
\usepackage{todonotes}
\usepackage[hidelinks]{hyperref}
\usepackage{languages}

\begin{document}

\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\title{Recaffeinating Java}
\subtitle{Modular and Concise Semantic Polymorphism for Java}

\authorinfo{Name1}
           {Affiliation1}
           {Email1}
\authorinfo{Name2}
           {Affiliation2}
           {Email2}

\maketitle

\begin{abstract}
\todo{mention CPS, language extensibility, syntax-driven transformation}
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

Over the years, many programming language extensibility mechanisms have
been proposed for interesting programming models (e.g., asynchronous
programming~\cite{bierman_pause_2012}, actor-based concurrency,
parallel programming, workflows, database queries~\cite{meijer_linq:_2006}). 
\fs{}~\emph{computation expressions}~\cite{petricek_f_2014}, macros,
Haskell Embedded DSLs (shallow/deep, do-notation for monads) are
mechanisms that create a familiar look--and--feel syntactically
without fixing the semantics of written code. Currently, vanilla
\java{} lacks such kind of lightweight extensibility.

% Aggelos: we will see about that.
In this work we introduce such syntactic flexibility using \emph{Object
  Algebras}~\cite{oliveira_extensibility_2012} (hereafter
\textbf{OAs}) as a device for the description of the semantics. OAs
are simple to understand, they solve the expression problem, they have
attracted a lot of attention in the research community in the area of
interpreters and have a simple model of development. Overall, this
will achieve an elegant and concise way in \java{} to author libraries
that affect the semantics of code. The motivating
observation for the current proposal is that \fs{}'s builders of
computation expressions~\cite[Chapter~6.3.10]{syme_f_2012} have an 1-1
correspondence with the signature of an OA. 

\section{Background}

\todo{mention fsharp}
Our work is inspired by \fs{}'s computation expressions. 
Async, AsyncSeq, Maybe, Cloud and many more define different semantics.
the translation is made during type checking phase:
can be characterised as type driven as shown 
%https://github.com/fsharp/fsharp/blob/master/src/fsharp/TypeChecker.fs#L7000 
but seems as a syntactic translation. 
\fs{} is monadic + operators (Bind + Return are monadic). Seq isn't build with this
pattern though. 

\todo{mention Dart for the translation process}

In \fs{} asynchronous workflows are designated with the \verb|async|
label which corresponds to a computation expression defined in the
standard library e.g.,

\begin{lstlisting}[style=fsharp]
let getLength url = async {
  let! html = fetchAsync url
  do! Async.Sleep 1000
  return html.Length
}
\end{lstlisting}

The corresponding translation is type-driven:

\begin{lstlisting}[style=fsharp]
async.Bind(fetchAsync(url), fun html ->
  async.Bind(Async.Sleep 1000, fun () ->
    async.Return(html.Length)))
\end{lstlisting}

\section{Java transformation into CPS}

\subsection{Delimiting transformation at the method level}

\section{Embedded DSLs}

\subsection{Async}

\paragraph{Recursive asynchronous fibonacci. }

\subsection{Yield with exceptions}

\paragraph{A pull-based stream library. }

\subsection{Generating HTML}

\todo{more sections to add}

\section{Related Work}

We follow a similar approach with scala-virtualized
\cite{moors_scalavirtualized_2012} although we perform our translation via a
separate rewriting tool.

Implementing First-Class Polymorphic Delimited Continuations by a Type
Directed Selective CPS-Transform~\cite{rompf_shift_2009}

Vazou et al, in From Monads to Effects and 
Back~\cite{vazou_koka_2016} rely on the theory of Representing 
Monads~\cite{filinski_representing_1994} and represent everything
as the continuation monad. We follow a similar approach based on the 
translation of Dart as described in ~\cite{meijer_dar_2015}. Lightweight
Monadic Programming~\cite{swamy_lightweight_2011} follows a type driven
approach. Tagless Interpreters~\cite{carette_finally_2007}

In~\cite{rompf_shift_2009}, Tiark et al, provide a selective, type-driven 
translation to add delimited continuations adopting the reset/shift static 
variant. Our work provides certain variants of embedded DSLs (including 
transfer of control) but not in a generic way as provided with a framework
like that. For control operations like yield we rely on a naive implementation 
via exceptions for exposition.

\section{Future Work}

That \emph{Monads do not compose} has been identified in Steele's
paper~\cite{steele_building_1994}. There are three approaches to solve
this problem (as identified in~\cite{kiselyov_freer_2015}): monad
transformers~\cite{liang_monad_1995}, the free monad as used
in~\cite{swierstra_data_2008} and side--effect--request
handlers~\cite{cartwright_extensible_1994}. One interesting research
question is to study the differences between these three and identify
early on, if we can borrow one technique and apply it to our
design. 

\bibliographystyle{abbrv}
\bibliography{paper}

\end{document}
