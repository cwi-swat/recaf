package generated;

import recaf.demo.pegs.MemoPEG;
import recaf.demo.pegs.PEGwithLayout;
import recaf.demo.pegs.Parser;

public class TestPEG {

  abstract class Exp { }
  
  class BinOp extends Exp {
    String op; Exp lhs, rhs;
    BinOp(String op, Exp lhs, Exp rhs) {
      this.op = op;
      this.lhs = lhs;
      this.rhs = rhs;
    }
    @Override
    public String toString() {
        return "(" + lhs + op + rhs + ")";
    }
  }
  
  class Int extends Exp {
    int value;
    Int(int n) {
      this.value = n;
    }
    @Override
    public String toString() {
        return "" + value;
    }
  }
  
  private final recaf PEGwithLayout<Exp> alg = new PEGwithLayout<Exp>("[\\ \\t\\n]*");
  
  recaf Parser<Exp> exp() {
    let Exp e = sum();
    return e;
  }

  recaf Parser<Exp> sum() {
    let Exp v1 = product();
    star Exp exp = (v1) {
      regexp String op = "[+\\-]";
      let Exp v2 = product();
      return new BinOp(op, exp, v2);
    }
    return exp;
  }
  
  recaf Parser<Exp> product() {
    let Exp v1 = value();
    star Exp exp = (v1) {
      regexp String op = "[*/]";
      let Exp v2 = value();
      return new BinOp(op, exp, v2);
    }
    return exp;
  }
  
  recaf Parser<Exp> value() {
    choice {
     alt "value":
      regexp String n = "[0-9]+";
      return new Int(Integer.parseInt(n));
      
     alt "bracket":
      lit! "(";
      let Exp e = exp();
      lit! ")";
      return e;
    }
  }
  
  public static void main(String args[]) {
    Parser<Exp> p = new TestPEG().exp();
    System.out.println(p.parse("(1 + 2) * (3 + 4)", 0).getValue());
  }
  
}